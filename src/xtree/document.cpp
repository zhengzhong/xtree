//
// Created by ZHENG Zhong on 2008-07-17.
//

#ifndef XTREE_SOURCE
#define XTREE_SOURCE
#endif

#include "xtree/document.hpp"
#include "xtree/exceptions.hpp"
#include "xtree/node.hpp"
#include "xtree/element.hpp"
#include "xtree/text.hpp"
#include "xtree/comment.hpp"
#include "xtree/child_node_list.hpp"

#include "xtree/xpath_context.hpp"
#include "xtree/xpath_result.hpp"
#include "xtree/node_set.hpp"

#include "xtree/libxml2_utility.hpp"

#include <libxml/tree.h>

#include <algorithm>
#include <cassert>
#include <map>
#include <sstream>
#include <string>
#include <vector>


namespace xtree {


    ////////////////////////////////////////////////////////////////////////////////////////////////
    // anonymous namespace
    //


    namespace {


        //! The prefix of the namespace prefix generated by the document.
        static const std::string PRE_PREFIX = "ns";


        int count_prefix(const std::string& prefix, int counter)
        {
            int suffix_number = 0;
            if (prefix.size() > PRE_PREFIX.size())
            {
                std::string pre_prefix = prefix.substr(0, PRE_PREFIX.size());
                if (pre_prefix == PRE_PREFIX)
                {
                    // Convert the suffix to a number.
                    for (std::string::size_type i = PRE_PREFIX.size(); i < prefix.size(); ++i)
                    {
                        if (prefix.at(i) >= '0' && prefix.at(i) <= '9')
                        {
                            suffix_number = 10 * suffix_number + (prefix.at(i) - '0');
                        }
                        else
                        {
                            suffix_number = 0; // reset to 0 if the suffix is not a valid number.
                            break;
                        }
                    }
                }
            }
            // Return the maximal value between counter and suffix.
            return (std::max)(suffix_number, counter);
        }


        int count_prefix_for_namespace(xmlNs* ns, int counter)
        {
            for (xmlNs* i = ns; i != 0; i = i->next)
            {
                if (i->prefix != 0)
                {
                    counter = count_prefix(detail::to_chars(i->prefix), counter);
                }
            }
            return counter;
        }


        int count_prefix_for_element(xmlNode* elem, int counter)
        {
            if (elem != 0 && elem->type == XML_ELEMENT_NODE)
            {
                counter = count_prefix_for_namespace(elem->nsDef, counter);
                for (xmlNode* i = elem->children; i != 0; i = i->next)
                {
                    counter = count_prefix_for_element(i, counter);
                }
            }
            return counter;
        }


        int count_prefix_for_document(xmlDoc* doc)
        {
            int counter = 0;
            if (doc != 0)
            {
                counter = count_prefix_for_namespace(doc->oldNs, counter);
                counter = count_prefix_for_element(xmlDocGetRootElement(doc), counter);
            }
            return counter;
        }


    }  // anonymous namespace


    ////////////////////////////////////////////////////////////////////////////////////////////////
    // constructor/destructor
    //


    document::document()
    : raw_( xmlNewDoc(detail::to_xml_chars("1.0")) ), children_(raw_), counter_(0), orphans_()
    {
        if (raw_ == 0)
        {
            throw internal_dom_error("fail to create libxml2 document: xmlNewDoc() returns null");
        }
        raw_->_private = this;
    }


    document::document(xmlDoc* px): raw_(px), children_(px), counter_(0), orphans_() {
        assert(raw_ != 0 && raw_->type == XML_DOCUMENT_NODE);
        raw_->_private = this;
        // TODO: counter_ = count_prefix_for_document(raw_);
    }


    document::~document()
    {
        // TODO: Free all orphan nodes.
        typedef std::vector<node*>::iterator iterator;
        for (iterator i = orphans_.begin(); i != orphans_.end(); ++i)
        {
            if (is_my_orphan_(*i))
            {
                node* orphan = *i;
                xmlUnlinkNode(orphan->raw());
                xmlFreeNode(orphan->raw());
            }
        }
        // Free the underlying libxml2 document.
        raw_->_private = 0;
        xmlFreeDoc(raw_);
        raw_ = 0;
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////
    // property access
    //


    std::string document::encoding() const
    {
        if (raw()->encoding != 0)
        {
            return detail::to_chars(raw()->encoding);
        }
        else
        {
            return std::string();
        }
    }


    std::string document::version() const
    {
        return "1.0";  // TODO: always 1.0?
    }


    bool document::empty() const
    {
        return ( root_() == 0 );
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////
    // children access
    //

    child_node_list& document::children()
    {
        return children_;
    }


    const child_node_list& document::children() const
    {
        return children_;
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////
    // root element access
    //


    basic_node_ptr<element> document::root()
    {
        return basic_node_ptr<element>( const_cast<element*>(root_()) );
    }


    basic_node_ptr<const element> document::root() const
    {
        return basic_node_ptr<const element>( root_() );
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////
    // serialization
    //


    std::string document::str() const
    {
        std::string tmp;
        str(tmp);
        return tmp;
    }


    void document::str(std::string& str) const
    {
        // Dump the document to a memory buffer: it is up to the caller to free the buffer.
        xmlChar* buffer = 0;
        int size = 0;
        xmlDocDumpMemory( const_cast<xmlDoc*>(raw()), &buffer, &size );
        // Save the buffer's contents to string.
        if (size > 0 && buffer != 0)
        {
            str = detail::to_chars(buffer);
        }
        else
        {
            str = std::string();
        }
        // Free the buffer.
        xmlFree(buffer);
        buffer = 0;
    }


    void document::save_to_file(const std::string& file_name) const
    {
        int size = xmlSaveFormatFileEnc(
            file_name.c_str(),
            const_cast<xmlDoc*>(raw()),
            0,
            0
        );
        (size > 0);
    }


    document* document::clone() const
    {
        xmlDoc* px = xmlCopyDoc(const_cast<xmlDoc*>(raw()), 1);
        if (px == 0)
        {
            throw internal_dom_error("fail to clone libxml2 document: xmlCopyDoc() returns null");
        }
        return new document(px);
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////
    // modifiers
    //


    void document::clear()
    {
        // TODO: Free all orphan nodes.
        for (std::vector<node*>::iterator i = orphans_.begin(); i != orphans_.end(); ++i) {
            if (is_my_orphan_(*i))
            {
                node* orphan = *i;
                xmlUnlinkNode(orphan->raw());
                xmlFreeNode(orphan->raw());
            }
        }
        // Remove and free the root element from the document.
        xmlNode* root = xmlDocGetRootElement(raw());
        if (root != 0)
        {
            xmlUnlinkNode(root);
            xmlFreeNode(root);
        }
        // TODO: Reset the namespace prefix counter.
        // counter_ = 0;
    }


    basic_node_ptr<element> document::reset_root(const std::string& name)
    {
        return reset_root(name, std::string());
    }


    basic_node_ptr<element> document::reset_root(const std::string& name, const std::string& uri)
    {
        // Create a new element without namespace.
        xmlNode* px = xmlNewDocNode( raw(), 0, detail::to_xml_chars(name.c_str()), 0 );
        if (px == 0)
        {
            std::string what = "fail to create libxml2 element: xmlNewDocNode() returns null";
            throw internal_dom_error(what);
        }
        else if (px->_private == 0)
        {
            std::string what = "fail to create libxml2 element: element contains null private";
            throw internal_dom_error(what);
        }
        // Reset the root element, and set the namespace URI.
        basic_node_ptr<element> root = reset_root_(px);
        if (!uri.empty())
        {
            root->set_uri(uri);
        }
        return root;
    }


    basic_node_ptr<element> document::reset_root_clone(const element& elem)
    {
        return reset_root_(elem.clone_raw(true));
    }


    basic_node_ptr<element> document::reset_root_adopt(element& elem)
    {
        return reset_root_(elem.raw());
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////
    // XPath
    //


    void document::select_nodes(const std::string& xpath, node_set& nodes)
    {
        select_nodes(xpath, std::map<std::string, std::string>(), nodes);
    }


    void document::select_nodes(const std::string& xpath,
                                const std::pair<std::string, std::string>& ns_mapping,
                                node_set& nodes)
    {
        std::map<std::string, std::string> ns_mappings;
        ns_mappings.insert(ns_mapping);
        select_nodes(xpath, ns_mappings, nodes);
    }


    void document::select_nodes(const std::string& xpath,
                                const std::map<std::string, std::string>& ns_mappings,
                                node_set& nodes)
    {
        xpath_context context(raw(), 0);
        typedef std::map<std::string, std::string>::const_iterator const_iterator;
        for (const_iterator i = ns_mappings.begin(); i != ns_mappings.end(); ++i)
        {
            context.register_ns(i->first, i->second);
        }
        context.eval(xpath, nodes);
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////
    // node creation
    //


    basic_node_ptr<element> document::make_element(const std::string& name) const
    {
        // Create a new libxml2 element node.
        xmlNode* px = xmlNewDocNode( const_cast<xmlDoc*>(raw()),
                                     0,
                                     detail::to_xml_chars(name.c_str()),
                                     0 );
        if (px == 0)
        {
            std::string what = "fail to create new element: xmlNewDocNode() returns null";
            throw internal_dom_error(what);
        }
        // Push the new libxml2 element to the orphan list and return.
        element* orphan = static_cast<element*>(px->_private);
        add_orphan_(orphan);
        return basic_node_ptr<element>(orphan);
    }


    basic_node_ptr<text> document::make_text(const std::string& value) const
    {
        // Create a new libxml2 text node.
        xmlNode* px = xmlNewDocText( const_cast<xmlDoc*>(raw()),
                                     detail::to_xml_chars(value.c_str()) );
        if (px == 0)
        {
            std::string what = "fail to create text node: xmlNewDocText() returns null";
            throw internal_dom_error(what);
        }
        // Push the new libxml2 text node to the orphan list and return.
        text* orphan = static_cast<text*>(px->_private);
        add_orphan_(orphan);
        return basic_node_ptr<text>(orphan);
    }


    basic_node_ptr<text> document::make_cdata(const std::string& value) const
    {
        xmlNode* px = xmlNewCDataBlock( const_cast<xmlDoc*>(raw()),
                                        detail::to_xml_chars(value.c_str()),
                                        static_cast<int>(value.size()) );
        if (px == 0)
        {
            std::string what = "fail to create CDATA node: xmlNewCDataBlock() returns null";
            throw internal_dom_error(what);
        }
        text* orphan = static_cast<text*>(px->_private);
        add_orphan_(orphan);
        return basic_node_ptr<text>(orphan);
    }


    basic_node_ptr<comment> document::make_comment(const std::string& value) const {
        xmlNode* px = xmlNewDocComment( const_cast<xmlDoc*>(raw()),
                                        detail::to_xml_chars(value.c_str()) );
        if (px == 0)
        {
            std::string what = "fail to create comment node: xmlNewDocComment() returns null";
            throw internal_dom_error(what);
        }
        comment* orphan = static_cast<comment*>(px->_private);
        add_orphan_(orphan);
        return basic_node_ptr<comment>(orphan);
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////
    // namespace prefix generation
    //


    std::string document::next_namespace_prefix() const
    {
        // TODO: how to guarantee that prefix is unique within the document?
        // When the root element is reset, or when an XML subtree is adopted into this document
        // (which is an operation on an element), the prefix counter must be recalculated.
        std::ostringstream oss;
        oss << PRE_PREFIX << ++counter_;
        return oss.str();
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////
    // private
    //


    const element* document::root_() const
    {
        const xmlNode* px = xmlDocGetRootElement( const_cast<xmlDoc*>(raw()) );
        if (px != 0)
        {
            return static_cast<const element*>(px->_private);
        }
        else
        {
            return 0;
        }
    }


    basic_node_ptr<element> document::reset_root_(xmlNode* px)
    {
        assert(px != 0);
        xmlNode* px_old = xmlDocSetRootElement(raw(), px);
        if (px_old != 0)
        {
            xmlUnlinkNode(px_old);
            xmlFreeNode(px_old);
        }
        // TODO: Now the document contains only a root element without namespace: it is safe to
        // reset the namespace prefix counter.
        // counter_ = 0;
        return basic_node_ptr<element>( static_cast<element*>(px->_private) );
    }


    bool document::is_my_orphan_(const node* orphan) const
    {
        return (
            orphan != 0                  // the node is not null, and...
            && orphan->is_orphan()       // is an orphan node, and...
            && &(orphan->doc()) == this  // belongs to this document.
        );
    }


    void document::add_orphan_(node* orphan) const
    {
        assert(is_my_orphan_(orphan));
        if (std::find(orphans_.begin(), orphans_.end(), orphan) == orphans_.end())
        {
            orphans_.push_back(orphan);
        }
    }


    void document::remove_orphan_(node*) const
    {
        // TODO: implement me!
    }


} // namespace xtree

